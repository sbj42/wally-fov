{"version":3,"sources":["webpack://WallyFov/webpack/bootstrap","webpack://WallyFov/./src/geom/index.ts","webpack://WallyFov/./src/index.ts","webpack://WallyFov/./src/field-of-view.ts","webpack://WallyFov/./src/geom/direction.ts","webpack://WallyFov/./src/geom/direction-flags.ts","webpack://WallyFov/./src/geom/offset.ts","webpack://WallyFov/./src/geom/size.ts","webpack://WallyFov/./src/geom/rectangle.ts","webpack://WallyFov/./src/geom/mask.ts","webpack://WallyFov/./src/geom/mask-rect.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","FieldOfViewMap","Direction","DirectionFlags","MaskRect","TileFlag","geom","DIRECTIONS","length","LOCAL_OFF","Offset","width","height","_size","Size","this","set","_tileFlags","Array","area","fill","_addFlag","off","flag","index","_removeFlag","addWall","x","y","dir","containsOffset","addCardinalDirection","directionOpposite","removeWall","getWalls","ALL","getWall","addBody","BODY","removeBody","getBody","getFieldOfView","chebyshevRadius","origin","boundRect","Rectangle","mask","_quadrant","xDir","yDir","startX","startY","endDX","Math","min","max","endDY","farYFlag","WALL_SOUTH","WALL_NORTH","farXFlag","WALL_EAST","WALL_WEST","startMapIndex","startMaskIndex","wedges","Number","POSITIVE_INFINITY","dy","yMapIndex","yMaskIndex","divYpos","divYneg","wedgeIndex","dx","mapIndex","maskIndex","slopeY","slopeX","setAt","wallY","wallX","cutWedge","low","high","splice","NORTH","EAST","SOUTH","WEST","flags","ret","X_FROM_CARDINAL_DIRECTION","Y_FROM_CARDINAL_DIRECTION","toString","copyFrom","other","addOffset","subtractOffset","forEach","cursor","callback","westX","northY","northWest","size","empty","initialValue","_bits","getAt","Mask","rect","outsideValue","_rectangle","_mask","_outsideValue"],"mappings":"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","file":"wally-fov-1.0.5.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\n","/*\r\n *  WallyFOV\r\n *  github.com/sbj42/wally-fov\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {Direction, DirectionFlags, MaskRect} from './geom';\r\n","import * as geom from './geom';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nenum TileFlag {\r\n    WALL_NORTH = 1 << geom.Direction.NORTH,\r\n    WALL_EAST  = 1 << geom.Direction.EAST,\r\n    WALL_WEST  = 1 << geom.Direction.WEST,\r\n    WALL_SOUTH = 1 << geom.Direction.SOUTH,\r\n    BODY       = 1 << geom.DIRECTIONS.length,\r\n}\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  The wedges are all stored in\r\n * a simple number array, with two numbers for each wedge.  These constants\r\n * (WEDGE_LOW and WEDGE_HIGH) help to identify which number is which.\r\n * WEDGE_COUNT is just how many numbers per wedge.\r\n */\r\nconst WEDGE_LOW = 0;\r\nconst WEDGE_HIGH = 1;\r\nconst WEDGE_COUNT = 2;\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nconst BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nconst WALL_EPSILON = BODY_EPSILON / 10;\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It starts out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>(this._size.area).fill(0);\r\n    }\r\n\r\n    private _addFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n\r\n    private _removeFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x: number, y: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF, 1 << dir);\r\n            LOCAL_OFF.addCardinalDirection(dir);\r\n            if (this._size.containsOffset(LOCAL_OFF)) {\r\n                this._addFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x: number, y: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF, 1 << dir);\r\n            LOCAL_OFF.addCardinalDirection(dir);\r\n            if (this._size.containsOffset(LOCAL_OFF)) {\r\n                this._removeFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            }\r\n        }\r\n    }\r\n\r\n    getWalls(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & geom.DirectionFlags.ALL;\r\n    }\r\n\r\n    getWall(x: number, y: number, dir: geom.Direction) {\r\n        return (this.getWalls(x, y) & (1 << dir)) !== 0;\r\n    }\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return (this._tileFlags[index] & TileFlag.BODY) !== 0;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number): geom.MaskRect {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new geom.MaskRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: geom.MaskRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDX = (Math.min(Math.max(startX + xDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.width) - startX) * xDir;\r\n        const endDY = (Math.min(Math.max(startY + yDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.height) - startY) * yDir;\r\n        if (endDX < 0 || endDY < 0) {\r\n            // the origin is outside of the map\r\n            return;\r\n        }\r\n        const farYFlag = yDir === 1 ? TileFlag.WALL_SOUTH : TileFlag.WALL_NORTH;\r\n        const farXFlag = xDir === 1 ? TileFlag.WALL_EAST : TileFlag.WALL_WEST;\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [0, Number.POSITIVE_INFINITY];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg;\r\n                 dx !== endDX && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeFar is the slope to the farthest corner\r\n                //   slopeX is the slope closest to the X axis\r\n                // this is always true:\r\n                //   slopeY < slopeFar < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---F\r\n\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n                    // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                    // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                    wedgeIndex = wedgeIndex + WEDGE_COUNT;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n                    continue;\r\n                }\r\n\r\n                // we can see this tile\r\n                mask.setAt(maskIndex, true);\r\n\r\n                // const/let must be at the top of a block, in order not to trigger deoptimization due to\r\n                // https://github.com/nodejs/node/issues/9729\r\n                {\r\n                    const wallY = (this._tileFlags[mapIndex] & farYFlag) !== 0;\r\n                    const wallX = (this._tileFlags[mapIndex] & farXFlag) !== 0;\r\n                    if (wallX && wallY) {\r\n                        // this tile has both far walls\r\n                        // so we can't see beyond it and the whole range should be cut out of the wedge(s)\r\n                        wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                    } else {\r\n                        const body = (dx !== 0 || dy !== 0) && (this._tileFlags[mapIndex] & TileFlag.BODY) !== 0;\r\n                        if (body) {\r\n                            if (wallX) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY + BODY_EPSILON, slopeX + WALL_EPSILON);\r\n                            } else if (wallY) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY - WALL_EPSILON, slopeX - BODY_EPSILON);\r\n                            } else {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                        } else if (wallX) {\r\n                            const slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                slopeFar - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                        } else if (wallY) {\r\n                            const slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                slopeY - WALL_EPSILON, slopeFar + WALL_EPSILON);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This function cuts a range of angles out of the wedge array.\r\n */\r\nfunction cutWedge(wedges: number[], wedgeIndex: number, low: number, high: number): number {\r\n    for (; ; ) {\r\n        if (wedgeIndex === wedges.length) {\r\n            return wedgeIndex;\r\n        }\r\n        if (low <= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            break;\r\n        }\r\n        // This next line is to cover a hypothetical edge case, where two slopes\r\n        // are not the same, but are within the BODY_EPSILON distance.  That\r\n        // would be due to either floating point error or due to a very large\r\n        // field radius.  Either way I haven't been able to construct a test\r\n        // case for it.\r\n        wedgeIndex += WEDGE_COUNT;\r\n    }\r\n    if (low <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n        if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            // wedge is entirely occluded, remove it\r\n            wedges.splice(wedgeIndex, WEDGE_COUNT);\r\n            // now looking at the next wedge (or past the end)\r\n            return cutWedge(wedges, wedgeIndex, low, high);\r\n        } else if (high >= wedges[wedgeIndex + WEDGE_LOW]) {\r\n            // low part of wedge is occluded, trim it\r\n            wedges[wedgeIndex + WEDGE_LOW] = high;\r\n            // still looking at the same wedge\r\n        } else {\r\n            // this cut doesn't reach the current wedge\r\n        }\r\n    } else if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n        // high part of wedge is occluded, trim it\r\n        wedges[wedgeIndex + WEDGE_HIGH] = low;\r\n        // move on to the next wedge\r\n        wedgeIndex += WEDGE_COUNT;\r\n        return cutWedge(wedges, wedgeIndex, low, high);\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        wedges.splice(wedgeIndex, 0, wedges[wedgeIndex + WEDGE_LOW], low);\r\n        wedgeIndex += WEDGE_COUNT;\r\n        wedges[wedgeIndex + WEDGE_LOW] = high;\r\n        // now looking at the second wedge of the split\r\n    }\r\n    return wedgeIndex;\r\n}\r\n","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n","import * as geom from '.';\r\n\r\nconst X_FROM_CARDINAL_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_CARDINAL_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_CARDINAL_DIRECTION[dir];\r\n        this.y += Y_FROM_CARDINAL_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n\r\n    forEach(cursor: geom.Offset, callback: (offset: geom.Offset) => void) {\r\n        for (let dy = 0; dy < this.height; dy ++) {\r\n            for (let dx = 0; dx < this.width; dx ++) {\r\n                cursor.x = dx;\r\n                cursor.y = dy;\r\n                callback(cursor);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        let index = 0;\r\n        this._size.forEach(cursor, (off) => {\r\n            callback(off, this._bits[index]);\r\n            index ++;\r\n        });\r\n    }\r\n}\r\n","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(LOCAL_OFF.subtractOffset(this._rectangle.northWest));\r\n    }\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.set(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest), value);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        this._mask.forEach(cursor, (off, value) => {\r\n            callback(off.addOffset(this._rectangle.northWest), value);\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":""}