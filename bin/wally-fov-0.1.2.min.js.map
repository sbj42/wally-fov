{"version":3,"sources":["webpack:///wally-fov-0.1.2.min.js","webpack:///webpack/bootstrap e672d64ba8006b641724","webpack:///./src/geom/index.ts","webpack:///./src/field-of-view.ts","webpack:///./src/geom/direction-flags.ts","webpack:///./src/geom/direction.ts","webpack:///./src/geom/mask-rect.ts","webpack:///./src/geom/mask.ts","webpack:///./src/geom/offset.ts","webpack:///./src/geom/rectangle.ts","webpack:///./src/geom/size.ts","webpack:///./src/index.ts"],"names":["WallyFov","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__export","cutWedge","wedges","wedgeIndex","low","high","length","WEDGE_HIGH","WEDGE_COUNT","WEDGE_LOW","splice","TileFlag","geom","DIRECTIONS","LOCAL_OFF","Offset","FieldOfViewMap","width","height","this","_size","Size","set","_tileFlags","Array","area","fill","_addFlag","off","flag","index","_removeFlag","addWall","x","y","dir","addCardinalDirection","containsOffset","directionOpposite","removeWall","getWalls","DirectionFlags","ALL","addBody","BODY","removeBody","getBody","getFieldOfView","chebyshevRadius","origin","boundRect","Rectangle","mask","MaskRect","_quadrant","xDir","yDir","startX","startY","endDX","Math","min","max","endDY","farYFlag","WALL_SOUTH","WALL_NORTH","farXFlag","WALL_EAST","WALL_WEST","startMapIndex","startMaskIndex","Number","POSITIVE_INFINITY","dy","yMapIndex","yMaskIndex","divYpos","divYneg","dx","mapIndex","maskIndex","slopeY","slopeX","setAt","wallY","wallX","body","slopeFar","directionFlagsToString","flags","ret","NORTH","EAST","SOUTH","WEST","directionFlagsFromDirection","Direction","rect","initialValue","outsideValue","_rectangle","copyFrom","_mask","Mask","_outsideValue","toString","northWest","westX","northY","subtractOffset","getAt","forEach","cursor","callback","_this","addOffset","size","_bits","X_FROM_CARDINAL_DIRECTION","Y_FROM_CARDINAL_DIRECTION","other","empty","field_of_view_1","geom_1"],"mappings":"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","file":"wally-fov-0.1.2.min.js","sourcesContent":["var WallyFov =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/bin/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nfunction __export(m) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__export(__webpack_require__(3));\r\n__export(__webpack_require__(2));\r\n__export(__webpack_require__(6));\r\n__export(__webpack_require__(8));\r\n__export(__webpack_require__(7));\r\n__export(__webpack_require__(5));\r\n__export(__webpack_require__(4));\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\n// tslint:disable:no-bitwise\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nvar TileFlag;\r\n(function (TileFlag) {\r\n    TileFlag[TileFlag[\"WALL_NORTH\"] = 1] = \"WALL_NORTH\";\r\n    TileFlag[TileFlag[\"WALL_EAST\"] = 2] = \"WALL_EAST\";\r\n    TileFlag[TileFlag[\"WALL_WEST\"] = 8] = \"WALL_WEST\";\r\n    TileFlag[TileFlag[\"WALL_SOUTH\"] = 4] = \"WALL_SOUTH\";\r\n    TileFlag[TileFlag[\"BODY\"] = 1 << geom.DIRECTIONS.length] = \"BODY\";\r\n})(TileFlag || (TileFlag = {}));\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  The wedges are all stored in\r\n * a simple number array, with two numbers for each wedge.  These constants\r\n * (WEDGE_LOW and WEDGE_HIGH) help to identify which number is which.\r\n * WEDGE_COUNT is just how many numbers per wedge.\r\n */\r\nvar WEDGE_LOW = 0;\r\nvar WEDGE_HIGH = 1;\r\nvar WEDGE_COUNT = 2;\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nvar BODY_EPSILON = 0.00001;\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nvar WALL_EPSILON = BODY_EPSILON / 10;\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nvar LOCAL_OFF = new geom.Offset();\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It start out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nvar FieldOfViewMap = /** @class */ (function () {\r\n    function FieldOfViewMap(width, height) {\r\n        this._size = new geom.Size();\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array(this._size.area).fill(0);\r\n    }\r\n    FieldOfViewMap.prototype._addFlag = function (off, flag) {\r\n        var index = this._size.index(off);\r\n        this._tileFlags[index] |= flag;\r\n    };\r\n    FieldOfViewMap.prototype._removeFlag = function (off, flag) {\r\n        var index = this._size.index(off);\r\n        this._tileFlags[index] &= ~flag;\r\n    };\r\n    // setup and maintenance\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    FieldOfViewMap.prototype.addWall = function (x, y, dir) {\r\n        LOCAL_OFF.set(x, y).addCardinalDirection(dir);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            LOCAL_OFF.set(x, y);\r\n            this._addFlag(LOCAL_OFF, 1 << dir);\r\n        }\r\n    };\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    FieldOfViewMap.prototype.removeWall = function (x, y, dir) {\r\n        LOCAL_OFF.set(x, y).addCardinalDirection(dir);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            LOCAL_OFF.set(x, y);\r\n            this._removeFlag(LOCAL_OFF, 1 << dir);\r\n        }\r\n    };\r\n    FieldOfViewMap.prototype.getWalls = function (x, y) {\r\n        LOCAL_OFF.set(x, y);\r\n        var index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & geom.DirectionFlags.ALL;\r\n    };\r\n    FieldOfViewMap.prototype.addBody = function (x, y) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, TileFlag.BODY);\r\n    };\r\n    FieldOfViewMap.prototype.removeBody = function (x, y) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, TileFlag.BODY);\r\n    };\r\n    FieldOfViewMap.prototype.getBody = function (x, y) {\r\n        LOCAL_OFF.set(x, y);\r\n        var index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & TileFlag.BODY;\r\n    };\r\n    // execution\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    FieldOfViewMap.prototype.getFieldOfView = function (x, y, chebyshevRadius) {\r\n        var origin = new geom.Offset(x, y);\r\n        var boundRect = new geom.Rectangle(origin.x - chebyshevRadius, origin.y - chebyshevRadius, chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1);\r\n        var mask = new geom.MaskRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, 1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, 1);\r\n        this._quadrant(mask, origin, chebyshevRadius, 1, 1);\r\n        return mask;\r\n    };\r\n    FieldOfViewMap.prototype._quadrant = function (mask, origin, chebyshevRadius, xDir, yDir) {\r\n        var startX = origin.x, startY = origin.y;\r\n        var endDX = (Math.min(Math.max(startX + xDir * (chebyshevRadius + 1), -1), this._size.width) - startX) * xDir;\r\n        var endDY = (Math.min(Math.max(startY + yDir * (chebyshevRadius + 1), -1), this._size.height) - startY) * yDir;\r\n        if (endDX < 0 || endDY < 0) {\r\n            // the origin is outside of the map\r\n            return;\r\n        }\r\n        var farYFlag = yDir === 1 ? TileFlag.WALL_SOUTH : TileFlag.WALL_NORTH;\r\n        var farXFlag = xDir === 1 ? TileFlag.WALL_EAST : TileFlag.WALL_WEST;\r\n        var startMapIndex = this._size.index(origin);\r\n        var startMaskIndex = mask.index(origin);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        var wedges = [0, Number.POSITIVE_INFINITY];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (var dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex; dy !== endDY && wedges.length > 0; dy++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width) {\r\n            var divYpos = 1 / (dy + 0.5);\r\n            var divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            var wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (var dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex, slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg; dx !== endDX && wedgeIndex !== wedges.length; dx++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                slopeY = slopeY + divYpos, slopeX = slopeX + divYneg) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeFar is the slope to the farthest corner\r\n                //   slopeX is the slope closest to the X axis\r\n                // this is always true:\r\n                //   slopeY < slopeFar < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---F\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n                    // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                    // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                    wedgeIndex = wedgeIndex + WEDGE_COUNT;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n                    continue;\r\n                }\r\n                // we can see this tile\r\n                mask.setAt(maskIndex, true);\r\n                // const/let must be at the top of a block, in order not to trigger deoptimization due to\r\n                // https://github.com/nodejs/node/issues/9729\r\n                {\r\n                    var wallY = (this._tileFlags[mapIndex] & farYFlag) !== 0;\r\n                    var wallX = (this._tileFlags[mapIndex] & farXFlag) !== 0;\r\n                    if (wallX && wallY) {\r\n                        // this tile has both far walls\r\n                        // so we can't see beyond it and the whole range should be cut out of the wedge(s)\r\n                        wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                    }\r\n                    else {\r\n                        var body = (dx !== 0 || dy !== 0) && (this._tileFlags[mapIndex] & TileFlag.BODY) !== 0;\r\n                        if (body) {\r\n                            if (wallX) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY + BODY_EPSILON, slopeX + WALL_EPSILON);\r\n                            }\r\n                            else if (wallY) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY - WALL_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                            else {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                        }\r\n                        else if (wallX) {\r\n                            var slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex, slopeFar - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                        }\r\n                        else if (wallY) {\r\n                            var slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY - WALL_EPSILON, slopeFar + WALL_EPSILON);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return FieldOfViewMap;\r\n}());\r\nexports.FieldOfViewMap = FieldOfViewMap;\r\n/**\r\n * This function cuts a range of angles out of the wedge array.\r\n */\r\nfunction cutWedge(wedges, wedgeIndex, low, high) {\r\n    for (;;) {\r\n        if (wedgeIndex === wedges.length) {\r\n            return wedgeIndex;\r\n        }\r\n        if (low <= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            break;\r\n        }\r\n        wedgeIndex += WEDGE_COUNT;\r\n    }\r\n    if (low <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n        if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            // wedge is entirely occluded, remove it\r\n            wedges.splice(wedgeIndex, WEDGE_COUNT);\r\n            // now looking at the next wedge (or past the end)\r\n            return cutWedge(wedges, wedgeIndex, low, high);\r\n        }\r\n        else if (high >= wedges[wedgeIndex + WEDGE_LOW]) {\r\n            // low part of wedge is occluded, trim it\r\n            wedges[wedgeIndex + WEDGE_LOW] = high;\r\n            // still looking at the same wedge\r\n        }\r\n        else {\r\n            // this cut doesn't reach the current wedge\r\n        }\r\n    }\r\n    else if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n        // high part of wedge is occluded, trim it\r\n        wedges[wedgeIndex + WEDGE_HIGH] = low;\r\n        // move on to the next wedge\r\n        wedgeIndex += WEDGE_COUNT;\r\n        return cutWedge(wedges, wedgeIndex, low, high);\r\n    }\r\n    else {\r\n        // middle part of wedge is occluded, split it\r\n        wedges.splice(wedgeIndex, 0, wedges[wedgeIndex + WEDGE_LOW], low);\r\n        wedgeIndex += WEDGE_COUNT;\r\n        wedges[wedgeIndex + WEDGE_LOW] = high;\r\n        // now looking at the second wedge of the split\r\n    }\r\n    return wedgeIndex;\r\n}\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// tslint:disable:no-bitwise\r\nvar DirectionFlags;\r\n(function (DirectionFlags) {\r\n    DirectionFlags[DirectionFlags[\"NONE\"] = 0] = \"NONE\";\r\n    DirectionFlags[DirectionFlags[\"NORTH\"] = 1] = \"NORTH\";\r\n    DirectionFlags[DirectionFlags[\"EAST\"] = 2] = \"EAST\";\r\n    DirectionFlags[DirectionFlags[\"SOUTH\"] = 4] = \"SOUTH\";\r\n    DirectionFlags[DirectionFlags[\"WEST\"] = 8] = \"WEST\";\r\n    DirectionFlags[DirectionFlags[\"ALL\"] = 15] = \"ALL\";\r\n})(DirectionFlags = exports.DirectionFlags || (exports.DirectionFlags = {}));\r\nfunction directionFlagsToString(flags) {\r\n    var ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\nexports.directionFlagsToString = directionFlagsToString;\r\n// conversion\r\nfunction directionFlagsFromDirection(dir) {\r\n    return (1 << dir);\r\n}\r\nexports.directionFlagsFromDirection = directionFlagsFromDirection;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n// tslint:disable:no-bitwise\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"NORTH\"] = 0] = \"NORTH\";\r\n    Direction[Direction[\"EAST\"] = 1] = \"EAST\";\r\n    Direction[Direction[\"SOUTH\"] = 2] = \"SOUTH\";\r\n    Direction[Direction[\"WEST\"] = 3] = \"WEST\";\r\n})(Direction = exports.Direction || (exports.Direction = {}));\r\nexports.DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\nfunction directionOpposite(dir) {\r\n    return ((dir + 2) & 3);\r\n}\r\nexports.directionOpposite = directionOpposite;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar LOCAL_OFF = new geom.Offset();\r\nvar MaskRect = /** @class */ (function () {\r\n    function MaskRect(rect, initialValue, outsideValue) {\r\n        if (initialValue === void 0) { initialValue = false; }\r\n        if (outsideValue === void 0) { outsideValue = false; }\r\n        this._rectangle = new geom.Rectangle();\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n    // accessors\r\n    MaskRect.prototype.toString = function () {\r\n        return this._rectangle.northWest + \"/\" + this._outsideValue + \"\\n\" + this._mask;\r\n    };\r\n    Object.defineProperty(MaskRect.prototype, \"westX\", {\r\n        get: function () {\r\n            return this._rectangle.westX;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"northY\", {\r\n        get: function () {\r\n            return this._rectangle.northY;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"width\", {\r\n        get: function () {\r\n            return this._rectangle.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(MaskRect.prototype, \"height\", {\r\n        get: function () {\r\n            return this._rectangle.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    MaskRect.prototype.index = function (off) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    };\r\n    MaskRect.prototype.getAt = function (index) {\r\n        return this._mask.getAt(index);\r\n    };\r\n    MaskRect.prototype.get = function (x, y) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(LOCAL_OFF.subtractOffset(this._rectangle.northWest));\r\n    };\r\n    // mutators\r\n    MaskRect.prototype.setAt = function (index, value) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    };\r\n    MaskRect.prototype.set = function (off, value) {\r\n        this._mask.set(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest), value);\r\n        return this;\r\n    };\r\n    // utilities\r\n    MaskRect.prototype.forEach = function (cursor, callback) {\r\n        var _this = this;\r\n        this._mask.forEach(cursor, function (off, value) {\r\n            callback(off.addOffset(_this._rectangle.northWest), value);\r\n        });\r\n    };\r\n    return MaskRect;\r\n}());\r\nexports.MaskRect = MaskRect;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar Mask = /** @class */ (function () {\r\n    // TODO consider Uint8Array for bits\r\n    function Mask(size, initialValue) {\r\n        if (initialValue === void 0) { initialValue = false; }\r\n        this._size = new geom.Size();\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array(this._size.area).fill(initialValue);\r\n    }\r\n    // accessors\r\n    Mask.prototype.toString = function () {\r\n        var ret = '';\r\n        var off = new geom.Offset();\r\n        for (var y = 0; y < this._size.height; y++) {\r\n            for (var x = 0; x < this._size.width; x++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    };\r\n    Object.defineProperty(Mask.prototype, \"width\", {\r\n        get: function () {\r\n            return this._size.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Mask.prototype, \"height\", {\r\n        get: function () {\r\n            return this._size.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Mask.prototype.index = function (off) {\r\n        return this._size.index(off);\r\n    };\r\n    Mask.prototype.getAt = function (index) {\r\n        return this._bits[index];\r\n    };\r\n    Mask.prototype.get = function (off) {\r\n        return this.getAt(this.index(off));\r\n    };\r\n    // mutators\r\n    Mask.prototype.setAt = function (index, value) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    };\r\n    Mask.prototype.set = function (off, value) {\r\n        return this.setAt(this.index(off), value);\r\n    };\r\n    // utilities\r\n    Mask.prototype.forEach = function (cursor, callback) {\r\n        var _this = this;\r\n        var index = 0;\r\n        this._size.forEach(cursor, function (off) {\r\n            callback(off, _this._bits[index]);\r\n            index++;\r\n        });\r\n    };\r\n    return Mask;\r\n}());\r\nexports.Mask = Mask;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar X_FROM_CARDINAL_DIRECTION = [0, 1, 0, -1];\r\nvar Y_FROM_CARDINAL_DIRECTION = [-1, 0, 1, 0];\r\nvar Offset = /** @class */ (function () {\r\n    function Offset(x, y) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    Offset.prototype.toString = function () {\r\n        return \"(\" + this.x + \",\" + this.y + \")\";\r\n    };\r\n    // mutators\r\n    Offset.prototype.set = function (x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    };\r\n    Offset.prototype.copyFrom = function (other) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    };\r\n    Offset.prototype.addOffset = function (off) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    };\r\n    Offset.prototype.addCardinalDirection = function (dir) {\r\n        this.x += X_FROM_CARDINAL_DIRECTION[dir];\r\n        this.y += Y_FROM_CARDINAL_DIRECTION[dir];\r\n        return this;\r\n    };\r\n    Offset.prototype.subtractOffset = function (off) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    };\r\n    return Offset;\r\n}());\r\nexports.Offset = Offset;\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar geom = __webpack_require__(0);\r\nvar LOCAL_OFF = new geom.Offset();\r\nvar Rectangle = /** @class */ (function () {\r\n    function Rectangle(westX, northY, width, height) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n    // accessors\r\n    Rectangle.prototype.toString = function () {\r\n        return \"(\" + this.westX + \",\" + this.northY + \" \" + this.width + \"x\" + this.height + \")\";\r\n    };\r\n    Object.defineProperty(Rectangle.prototype, \"northY\", {\r\n        get: function () {\r\n            return this.northWest.y;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"southY\", {\r\n        get: function () {\r\n            return this.northWest.y + this.size.height - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"westX\", {\r\n        get: function () {\r\n            return this.northWest.x;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"eastX\", {\r\n        get: function () {\r\n            return this.northWest.x + this.size.width - 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"width\", {\r\n        get: function () {\r\n            return this.size.width;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"height\", {\r\n        get: function () {\r\n            return this.size.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"empty\", {\r\n        get: function () {\r\n            return this.size.empty;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Rectangle.prototype, \"area\", {\r\n        get: function () {\r\n            return this.size.area;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // mutators\r\n    Rectangle.prototype.copyFrom = function (other) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    };\r\n    // utilities\r\n    Rectangle.prototype.containsOffset = function (off) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    };\r\n    Rectangle.prototype.index = function (off) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    };\r\n    return Rectangle;\r\n}());\r\nexports.Rectangle = Rectangle;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Size = /** @class */ (function () {\r\n    function Size(width, height) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    // accessors\r\n    Size.prototype.toString = function () {\r\n        return \"(\" + this.width + \"x\" + this.height + \")\";\r\n    };\r\n    Object.defineProperty(Size.prototype, \"empty\", {\r\n        get: function () {\r\n            return this.width === 0 || this.height === 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Size.prototype, \"area\", {\r\n        get: function () {\r\n            return this.width * this.height;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // mutators\r\n    Size.prototype.set = function (width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    };\r\n    Size.prototype.copyFrom = function (other) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    };\r\n    // utilities\r\n    Size.prototype.containsOffset = function (off) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    };\r\n    Size.prototype.index = function (off) {\r\n        return off.y * this.width + off.x;\r\n    };\r\n    Size.prototype.forEach = function (cursor, callback) {\r\n        for (var dy = 0; dy < this.height; dy++) {\r\n            for (var dx = 0; dx < this.width; dx++) {\r\n                cursor.x = dx;\r\n                cursor.y = dy;\r\n                callback(cursor);\r\n            }\r\n        }\r\n    };\r\n    return Size;\r\n}());\r\nexports.Size = Size;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar field_of_view_1 = __webpack_require__(1);\r\nexports.FieldOfViewMap = field_of_view_1.FieldOfViewMap;\r\nvar geom_1 = __webpack_require__(0);\r\nexports.Direction = geom_1.Direction;\r\nexports.DirectionFlags = geom_1.DirectionFlags;\r\nexports.MaskRect = geom_1.MaskRect;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// wally-fov-0.1.2.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/bin/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e672d64ba8006b641724","export * from './direction';\r\nexport * from './direction-flags';\r\nexport * from './offset';\r\nexport * from './size';\r\nexport * from './rectangle';\r\nexport * from './mask';\r\nexport * from './mask-rect';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/index.ts","import * as geom from './geom';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\n/**\r\n * These flags determine whether a given tile has walls in any of the cardinal\r\n * directions, and whether there is a \"body\" in the tile.\r\n */\r\nenum TileFlag {\r\n    WALL_NORTH = 1 << geom.Direction.NORTH,\r\n    WALL_EAST  = 1 << geom.Direction.EAST,\r\n    WALL_WEST  = 1 << geom.Direction.WEST,\r\n    WALL_SOUTH = 1 << geom.Direction.SOUTH,\r\n    BODY       = 1 << geom.DIRECTIONS.length,\r\n}\r\n\r\n/**\r\n * In the shadowcasting algorithm, each shadow is represented by a \"wedge\",\r\n * running from a \"low\" angle to a \"high\" angle.  The wedges are all stored in\r\n * a simple number array, with two numbers for each wedge.  These constants\r\n * (WEDGE_LOW and WEDGE_HIGH) help to identify which number is which.\r\n * WEDGE_COUNT is just how many numbers per wedge.\r\n */\r\nconst WEDGE_LOW = 0;\r\nconst WEDGE_HIGH = 1;\r\nconst WEDGE_COUNT = 2;\r\n\r\n/**\r\n * Bodies in this algorithm do not entirely fill their tiles.  This is\r\n * implemented by adjusting the angles of the shadows the bodies cast,\r\n * making the wedge very slightly narrower.  BODY_EPSILON represents the\r\n * amount of reduction on either side of the wedge.\r\n */\r\nconst BODY_EPSILON = 0.00001;\r\n\r\n/**\r\n * Walls do fill the entire tile edge.  With infinite precision, there would be\r\n * no need to adjust the shadow cast by a wall.  But we're using floating point\r\n * math here, which means imprecision can creep in and cause angles not to line\r\n * up properly.  To fix that, we widen the wedges of the shadows cast by walls.\r\n * We must make sure not to widen them as much as we narrow the body shadows,\r\n * or else they might close the gap we want between a body and a wall.\r\n */\r\nconst WALL_EPSILON = BODY_EPSILON / 10;\r\n\r\n/**\r\n * We avoid heap allocations during the core part of the algorithm by using this\r\n * preallocated offset object.\r\n */\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\n/**\r\n * The FieldOFViewMap represents the map over which the field of view will be\r\n * computed.  It start out empty.  You can add walls and bodies to it, and then\r\n * use getFieldOfView() to compute the field of view from a given point.\r\n */\r\nexport class FieldOfViewMap {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _tileFlags: number[];\r\n\r\n    constructor(width: number, height: number) {\r\n        this._size.set(width, height);\r\n        this._tileFlags = new Array<number>(this._size.area).fill(0);\r\n    }\r\n\r\n    private _addFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] |= flag;\r\n    }\r\n\r\n    private _removeFlag(off: geom.OffsetLike, flag: TileFlag) {\r\n        const index = this._size.index(off);\r\n        this._tileFlags[index] &= ~flag;\r\n    }\r\n\r\n    // setup and maintenance\r\n\r\n    /**\r\n     * Adds a wall at a particular edge.  This automatically adds the\r\n     * corresponding wall on the other side.\r\n     */\r\n    addWall(x: number, y: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(x, y).addCardinalDirection(dir);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._addFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            LOCAL_OFF.set(x, y);\r\n            this._addFlag(LOCAL_OFF, 1 << dir);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a wall at a particular edge.  This automatically removes the\r\n     * corresponding wall on the other side.\r\n     */\r\n    removeWall(x: number, y: number, dir: geom.Direction) {\r\n        LOCAL_OFF.set(x, y).addCardinalDirection(dir);\r\n        if (this._size.containsOffset(LOCAL_OFF)) {\r\n            this._removeFlag(LOCAL_OFF, 1 << geom.directionOpposite(dir));\r\n            LOCAL_OFF.set(x, y);\r\n            this._removeFlag(LOCAL_OFF, 1 << dir);\r\n        }\r\n    }\r\n\r\n    getWalls(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & geom.DirectionFlags.ALL;\r\n    }\r\n\r\n    addBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._addFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    removeBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        this._removeFlag(LOCAL_OFF, TileFlag.BODY);\r\n    }\r\n\r\n    getBody(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        const index = this._size.index(LOCAL_OFF);\r\n        return this._tileFlags[index] & TileFlag.BODY;\r\n    }\r\n\r\n    // execution\r\n\r\n    /**\r\n     * Compute the field of view for a camera at the given tile.\r\n     * chebyshevRadius is the vision radius.  It uses chebyshev distance\r\n     * (https://en.wikipedia.org/wiki/Chebyshev_distance), which just means\r\n     * that the limit of vision in a large empty field will be square.\r\n     *\r\n     * This returns a MaskRect, which indicates which tiles are visible.\r\n     * maskRect.get(x, y) will return true for visible tiles.\r\n     */\r\n    getFieldOfView(x: number, y: number, chebyshevRadius: number): geom.MaskRect {\r\n        const origin = new geom.Offset(x, y);\r\n        const boundRect = new geom.Rectangle(\r\n            origin.x - chebyshevRadius, origin.y - chebyshevRadius,\r\n            chebyshevRadius * 2 + 1, chebyshevRadius * 2 + 1,\r\n        );\r\n        const mask = new geom.MaskRect(boundRect);\r\n        // the player can always see itself\r\n        mask.set(origin, true);\r\n        // the field is divided into quadrants\r\n        this._quadrant(mask, origin, chebyshevRadius, -1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1, -1);\r\n        this._quadrant(mask, origin, chebyshevRadius, -1,  1);\r\n        this._quadrant(mask, origin, chebyshevRadius,  1,  1);\r\n        return mask;\r\n    }\r\n\r\n    private _quadrant(mask: geom.MaskRect, origin: geom.OffsetLike, chebyshevRadius: number,\r\n                      xDir: number, yDir: number) {\r\n        const {x: startX, y: startY} = origin;\r\n        const endDX = (Math.min(Math.max(startX + xDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.width) - startX) * xDir;\r\n        const endDY = (Math.min(Math.max(startY + yDir * (chebyshevRadius + 1),\r\n                                         -1), this._size.height) - startY) * yDir;\r\n        if (endDX < 0 || endDY < 0) {\r\n            // the origin is outside of the map\r\n            return;\r\n        }\r\n        const farYFlag = yDir === 1 ? TileFlag.WALL_SOUTH : TileFlag.WALL_NORTH;\r\n        const farXFlag = xDir === 1 ? TileFlag.WALL_EAST : TileFlag.WALL_WEST;\r\n        const startMapIndex = this._size.index(origin);\r\n        const startMaskIndex = mask.index(origin);\r\n        // Initial wedge is from slope zero to slope infinity (i.e. the whole quadrant)\r\n        const wedges = [0, Number.POSITIVE_INFINITY];\r\n        // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n        // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n        for (let dy = 0, yMapIndex = startMapIndex, yMaskIndex = startMaskIndex;\r\n             dy !== endDY && wedges.length > 0;\r\n             dy ++, yMapIndex = yMapIndex + yDir * this._size.width, yMaskIndex = yMaskIndex + yDir * mask.width\r\n        ) {\r\n            const divYpos = 1 / (dy + 0.5);\r\n            const divYneg = dy === 0 ? Number.POSITIVE_INFINITY : 1 / (dy - 0.5);\r\n            let wedgeIndex = 0;\r\n            // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n            // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n            for (let dx = 0, mapIndex = yMapIndex, maskIndex = yMaskIndex,\r\n                 slopeY = -0.5 * divYpos, slopeX = 0.5 * divYneg;\r\n                 dx !== endDX && wedgeIndex !== wedges.length;\r\n                 dx ++, mapIndex = mapIndex + xDir, maskIndex = maskIndex + xDir,\r\n                 slopeY = slopeY + divYpos, slopeX = slopeX + divYneg\r\n            ) {\r\n                // the slopes of the four corners of this tile\r\n                // these are named as follows:\r\n                //   slopeY is the slope closest to the Y axis\r\n                //   slopeFar is the slope to the farthest corner\r\n                //   slopeX is the slope closest to the X axis\r\n                // this is always true:\r\n                //   slopeY < slopeFar < slopeX\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---X\r\n                // |   |   | C |\r\n                // +---+---Y---F\r\n\r\n                // the walls of this tile\r\n                // these are named as follows:\r\n                //   wallY is the farthest horizontal wall (slopeY to slopeFar)\r\n                //   wallX is the farthest vertical wall (slopeFar to slopeX)\r\n                //\r\n                // O = origin, C = current\r\n                // +---+---+---+\r\n                // | O |   |   |\r\n                // +---+---+---+\r\n                // |   |   | C X\r\n                // +---+---+-Y-+\r\n\r\n                // advance the wedge index until this tile is not after the current wedge\r\n                while (slopeY >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n                    // X += Y must be written as X = X + Y, in order not to trigger deoptimization due to\r\n                    // http://stackoverflow.com/questions/34595356/what-does-compound-let-const-assignment-mean\r\n                    wedgeIndex = wedgeIndex + WEDGE_COUNT;\r\n                    if (wedgeIndex >= wedges.length) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wedgeIndex >= wedges.length) {\r\n                    break;\r\n                }\r\n\r\n                // if the current wedge is after this tile, move on\r\n                if (slopeX <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n                    continue;\r\n                }\r\n\r\n                // we can see this tile\r\n                mask.setAt(maskIndex, true);\r\n\r\n                // const/let must be at the top of a block, in order not to trigger deoptimization due to\r\n                // https://github.com/nodejs/node/issues/9729\r\n                {\r\n                    const wallY = (this._tileFlags[mapIndex] & farYFlag) !== 0;\r\n                    const wallX = (this._tileFlags[mapIndex] & farXFlag) !== 0;\r\n                    if (wallX && wallY) {\r\n                        // this tile has both far walls\r\n                        // so we can't see beyond it and the whole range should be cut out of the wedge(s)\r\n                        wedgeIndex = cutWedge(wedges, wedgeIndex, slopeY - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                    } else {\r\n                        const body = (dx !== 0 || dy !== 0) && (this._tileFlags[mapIndex] & TileFlag.BODY) !== 0;\r\n                        if (body) {\r\n                            if (wallX) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY + BODY_EPSILON, slopeX + WALL_EPSILON);\r\n                            } else if (wallY) {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY - WALL_EPSILON, slopeX - BODY_EPSILON);\r\n                            } else {\r\n                                wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                    slopeY + BODY_EPSILON, slopeX - BODY_EPSILON);\r\n                            }\r\n                        } else if (wallX) {\r\n                            const slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                slopeFar - WALL_EPSILON, slopeX + WALL_EPSILON);\r\n                        } else if (wallY) {\r\n                            const slopeFar = slopeY + divYpos;\r\n                            wedgeIndex = cutWedge(wedges, wedgeIndex,\r\n                                slopeY - WALL_EPSILON, slopeFar + WALL_EPSILON);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This function cuts a range of angles out of the wedge array.\r\n */\r\nfunction cutWedge(wedges: number[], wedgeIndex: number, low: number, high: number): number {\r\n    for (; ; ) {\r\n        if (wedgeIndex === wedges.length) {\r\n            return wedgeIndex;\r\n        }\r\n        if (low <= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            break;\r\n        }\r\n        wedgeIndex += WEDGE_COUNT;\r\n    }\r\n    if (low <= wedges[wedgeIndex + WEDGE_LOW]) {\r\n        if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n            // wedge is entirely occluded, remove it\r\n            wedges.splice(wedgeIndex, WEDGE_COUNT);\r\n            // now looking at the next wedge (or past the end)\r\n            return cutWedge(wedges, wedgeIndex, low, high);\r\n        } else if (high >= wedges[wedgeIndex + WEDGE_LOW]) {\r\n            // low part of wedge is occluded, trim it\r\n            wedges[wedgeIndex + WEDGE_LOW] = high;\r\n            // still looking at the same wedge\r\n        } else {\r\n            // this cut doesn't reach the current wedge\r\n        }\r\n    } else if (high >= wedges[wedgeIndex + WEDGE_HIGH]) {\r\n        // high part of wedge is occluded, trim it\r\n        wedges[wedgeIndex + WEDGE_HIGH] = low;\r\n        // move on to the next wedge\r\n        wedgeIndex += WEDGE_COUNT;\r\n        return cutWedge(wedges, wedgeIndex, low, high);\r\n    } else {\r\n        // middle part of wedge is occluded, split it\r\n        wedges.splice(wedgeIndex, 0, wedges[wedgeIndex + WEDGE_LOW], low);\r\n        wedgeIndex += WEDGE_COUNT;\r\n        wedges[wedgeIndex + WEDGE_LOW] = high;\r\n        // now looking at the second wedge of the split\r\n    }\r\n    return wedgeIndex;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/field-of-view.ts","import * as geom from '.';\r\n\r\n// tslint:disable:no-bitwise\r\n\r\nexport enum DirectionFlags {\r\n    NONE  = 0,\r\n    NORTH = 1,\r\n    EAST  = 2,\r\n    SOUTH = 4,\r\n    WEST  = 8,\r\n    ALL   = 15,\r\n}\r\n\r\nexport function directionFlagsToString(flags: DirectionFlags) {\r\n    let ret = '[';\r\n    if ((flags & DirectionFlags.NORTH) !== 0) {\r\n        ret += 'N';\r\n    }\r\n    if ((flags & DirectionFlags.EAST) !== 0) {\r\n        ret += 'E';\r\n    }\r\n    if ((flags & DirectionFlags.SOUTH) !== 0) {\r\n        ret += 'S';\r\n    }\r\n    if ((flags & DirectionFlags.WEST) !== 0) {\r\n        ret += 'W';\r\n    }\r\n    return ret + ']';\r\n}\r\n\r\n// conversion\r\n\r\nexport function directionFlagsFromDirection(dir: geom.Direction) {\r\n    return (1 << dir) as DirectionFlags;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/direction-flags.ts","// tslint:disable:no-bitwise\r\n\r\nexport enum Direction {\r\n    NORTH = 0,\r\n    EAST  = 1,\r\n    SOUTH = 2,\r\n    WEST  = 3,\r\n}\r\n\r\nexport const DIRECTIONS = [\r\n    Direction.NORTH,\r\n    Direction.EAST,\r\n    Direction.SOUTH,\r\n    Direction.WEST,\r\n];\r\n\r\nexport function directionOpposite(dir: Direction) {\r\n    return ((dir + 2) & 3) as Direction;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/direction.ts","import * as geom from '.';\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class MaskRect implements geom.RectangleLike {\r\n    private readonly _rectangle = new geom.Rectangle();\r\n    private readonly _mask: geom.Mask;\r\n    private readonly _outsideValue: boolean;\r\n\r\n    constructor(rect: geom.RectangleLike, initialValue = false, outsideValue = false) {\r\n        this._rectangle.copyFrom(rect);\r\n        this._mask = new geom.Mask(rect, initialValue);\r\n        this._outsideValue = outsideValue;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `${this._rectangle.northWest}/${this._outsideValue}\\n${this._mask}`;\r\n    }\r\n\r\n    get westX() {\r\n        return this._rectangle.westX;\r\n    }\r\n\r\n    get northY() {\r\n        return this._rectangle.northY;\r\n    }\r\n\r\n    get width() {\r\n        return this._rectangle.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._rectangle.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._mask.index(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest));\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._mask.getAt(index);\r\n    }\r\n\r\n    get(x: number, y: number) {\r\n        LOCAL_OFF.set(x, y);\r\n        if (!this._rectangle.containsOffset(LOCAL_OFF)) {\r\n            return this._outsideValue;\r\n        }\r\n        return this._mask.get(LOCAL_OFF.subtractOffset(this._rectangle.northWest));\r\n    }\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._mask.setAt(index, value);\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        this._mask.set(LOCAL_OFF.copyFrom(off).subtractOffset(this._rectangle.northWest), value);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        this._mask.forEach(cursor, (off, value) => {\r\n            callback(off.addOffset(this._rectangle.northWest), value);\r\n        });\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/mask-rect.ts","import * as geom from '.';\r\n\r\nexport class Mask implements geom.SizeLike {\r\n    private readonly _size = new geom.Size();\r\n    private readonly _bits: boolean[];\r\n    // TODO consider Uint8Array for bits\r\n\r\n    constructor(size: geom.SizeLike, initialValue = false) {\r\n        this._size.copyFrom(size);\r\n        this._bits = new Array<boolean>(this._size.area).fill(initialValue);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        let ret = '';\r\n        const off = new geom.Offset();\r\n        for (let y = 0; y < this._size.height; y ++) {\r\n            for (let x = 0; x < this._size.width; x ++) {\r\n                off.set(x, y);\r\n                ret += this.get(off.set(x, y)) ? '☑' : '☐';\r\n            }\r\n            ret += '\\n';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    get width() {\r\n        return this._size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this._size.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this._size.index(off);\r\n    }\r\n\r\n    getAt(index: number) {\r\n        return this._bits[index];\r\n    }\r\n\r\n    get(off: geom.OffsetLike) {\r\n        return this.getAt(this.index(off));\r\n    }\r\n\r\n    // mutators\r\n\r\n    setAt(index: number, value: boolean) {\r\n        this._bits[index] = value;\r\n        return this;\r\n    }\r\n\r\n    set(off: geom.OffsetLike, value: boolean) {\r\n        return this.setAt(this.index(off), value);\r\n    }\r\n\r\n    // utilities\r\n\r\n    forEach(cursor: geom.Offset, callback: (cursor: geom.Offset, value: boolean) => void) {\r\n        let index = 0;\r\n        this._size.forEach(cursor, (off) => {\r\n            callback(off, this._bits[index]);\r\n            index ++;\r\n        });\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/mask.ts","import * as geom from '.';\r\n\r\nconst X_FROM_CARDINAL_DIRECTION = [  0, 1, 0, -1 ];\r\nconst Y_FROM_CARDINAL_DIRECTION = [ -1, 0, 1,  0 ];\r\n\r\nexport interface OffsetLike {\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\nexport class Offset implements OffsetLike {\r\n    x: number;\r\n    y: number;\r\n\r\n    constructor();\r\n    constructor(x: number, y: number);\r\n    constructor(x?: number, y?: number) {\r\n        if (typeof x === 'undefined') {\r\n            x = 0;\r\n        }\r\n        if (typeof y === 'undefined') {\r\n            y = 0;\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    toString() {\r\n        return `(${this.x},${this.y})`;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: OffsetLike) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        return this;\r\n    }\r\n\r\n    addOffset(off: OffsetLike) {\r\n        this.x += off.x;\r\n        this.y += off.y;\r\n        return this;\r\n    }\r\n\r\n    addCardinalDirection(dir: geom.Direction) {\r\n        this.x += X_FROM_CARDINAL_DIRECTION[dir];\r\n        this.y += Y_FROM_CARDINAL_DIRECTION[dir];\r\n        return this;\r\n    }\r\n\r\n    subtractOffset(off: OffsetLike) {\r\n        this.x -= off.x;\r\n        this.y -= off.y;\r\n        return this;\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/offset.ts","import * as geom from '.';\r\n\r\nexport interface RectangleLike extends geom.SizeLike {\r\n    readonly westX: number;\r\n    readonly northY: number;\r\n}\r\n\r\nconst LOCAL_OFF = new geom.Offset();\r\n\r\nexport class Rectangle implements RectangleLike, geom.SizeLike {\r\n    northWest: geom.Offset;\r\n    size: geom.Size;\r\n\r\n    constructor();\r\n    constructor(westX: number, northY: number, width: number, height: number);\r\n    constructor(westX?: number, northY?: number, width?: number, height?: number) {\r\n        if (typeof westX === 'undefined') {\r\n            westX = 0;\r\n        }\r\n        if (typeof northY === 'undefined') {\r\n            northY = 0;\r\n        }\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.northWest = new geom.Offset(westX, northY);\r\n        this.size = new geom.Size(width, height);\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.westX},${this.northY} ${this.width}x${this.height})`;\r\n    }\r\n\r\n    get northY() {\r\n        return this.northWest.y;\r\n    }\r\n\r\n    get southY() {\r\n        return this.northWest.y + this.size.height - 1;\r\n    }\r\n\r\n    get westX() {\r\n        return this.northWest.x;\r\n    }\r\n\r\n    get eastX() {\r\n        return this.northWest.x + this.size.width - 1;\r\n    }\r\n\r\n    get width() {\r\n        return this.size.width;\r\n    }\r\n\r\n    get height() {\r\n        return this.size.height;\r\n    }\r\n\r\n    get empty() {\r\n        return this.size.empty;\r\n    }\r\n\r\n    get area() {\r\n        return this.size.area;\r\n    }\r\n\r\n    // mutators\r\n\r\n    copyFrom(other: RectangleLike) {\r\n        this.northWest.set(other.westX, other.northY);\r\n        this.size.set(other.width, other.height);\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return this.size.containsOffset(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return this.size.index(LOCAL_OFF.copyFrom(off).subtractOffset(this.northWest));\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/rectangle.ts","import * as geom from '.';\r\n\r\nexport interface SizeLike {\r\n    readonly width: number;\r\n    readonly height: number;\r\n}\r\n\r\nexport class Size implements SizeLike {\r\n    width: number;\r\n    height: number;\r\n\r\n    constructor();\r\n    constructor(width: number, height: number);\r\n    constructor(width?: number, height?: number) {\r\n        if (typeof width === 'undefined') {\r\n            width = 0;\r\n        }\r\n        if (typeof height === 'undefined') {\r\n            height = 0;\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    // accessors\r\n\r\n    toString() {\r\n        return `(${this.width}x${this.height})`;\r\n    }\r\n\r\n    get empty() {\r\n        return this.width === 0 || this.height === 0;\r\n    }\r\n\r\n    get area() {\r\n        return this.width * this.height;\r\n    }\r\n\r\n    // mutators\r\n\r\n    set(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    copyFrom(other: SizeLike) {\r\n        this.width = other.width;\r\n        this.height = other.height;\r\n        return this;\r\n    }\r\n\r\n    // utilities\r\n\r\n    containsOffset(off: geom.OffsetLike) {\r\n        return off.x >= 0 && off.y >= 0 && off.x < this.width && off.y < this.height;\r\n    }\r\n\r\n    index(off: geom.OffsetLike) {\r\n        return off.y * this.width + off.x;\r\n    }\r\n\r\n    forEach(cursor: geom.Offset, callback: (offset: geom.Offset) => void) {\r\n        for (let dy = 0; dy < this.height; dy ++) {\r\n            for (let dx = 0; dx < this.width; dx ++) {\r\n                cursor.x = dx;\r\n                cursor.y = dy;\r\n                callback(cursor);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/geom/size.ts","/*\r\n *  WallyFOV\r\n *  github.com/sbj42/WallyFOV\r\n *  James Clark\r\n *  Licensed under the MIT license.\r\n */\r\n\r\nexport {FieldOfViewMap} from './field-of-view';\r\nexport {Direction, DirectionFlags, MaskRect} from './geom';\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts"],"sourceRoot":""}